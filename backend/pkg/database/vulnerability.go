// Copyright Â© 2022 Cisco Systems, Inc. and its affiliates.
// All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package database

import (
	"encoding/json"
	"fmt"
	"strings"
	"time"

	"github.com/go-openapi/strfmt"
	uuid "github.com/satori/go.uuid"
	log "github.com/sirupsen/logrus"
	"gorm.io/gorm"

	"github.com/openclarity/kubeclarity/api/server/models"
	"github.com/openclarity/kubeclarity/api/server/restapi/operations"
	"github.com/openclarity/kubeclarity/backend/pkg/types"
)

const (
	vulnerabilityTableName = "vulnerabilities"
	vulnerabilityViewName  = "vulnerabilities_view"

	// NOTE: when changing one of the column names change also the gorm label in Vulnerability.
	columnVulID                = "id"
	columnVulName              = "name"
	columnVulSeverity          = "severity"
	columnVulCVSSBaseScore     = "cvss_base_score"
	columnVulReportingScanners = "reporting_scanners"
	columnVulSource            = "source"

	// NOTE: when changing one of the column names change also the gorm label in VulnerabilityView.
	columnVulViewApplications   = "applications"
	columnVulViewVulID          = "id"
	columnVulViewResources      = "resources"
	columnVulViewPkgID          = "package_id"
	columnVulViewFixVersion     = "fix_version"
	columnVulViewPackageName    = "package_name"
	columnVulViewPackageVersion = "package_version"
)

type Vulnerability struct {
	ID string `gorm:"primarykey" faker:"-"` // consists of the vulnerability name

	Name        string    `json:"name,omitempty" gorm:"column:name" faker:"oneof: vul1, vul2, vul3, vul4, vul5"`
	ScannedAt   time.Time `json:"scanned_at,omitempty" gorm:"column:scanned_at" faker:"-"`
	Severity    int       `json:"severity,omitempty" gorm:"column:severity" faker:"oneof: 3, 2, 1, 0"`
	Description string    `json:"description,omitempty" gorm:"column:description" faker:"-"`
	Links       string    `json:"links,omitempty" gorm:"column:links" faker:"oneof: |link1|, |link1||link2|"`
	// Serialized CVSS struct
	CVSS              string                     `json:"cvss,omitempty" gorm:"column:cvss" faker:"-"`
	CVSSBaseScore     float64                    `json:"cvss_base_score,omitempty" gorm:"column:cvss_base_score" faker:"-"`
	CVSSSeverity      int                        `json:"cvss_severity,omitempty" gorm:"column:cvss_severity" faker:"-"`
	ReportingScanners string                     `json:"reporting_scanners,omitempty" gorm:"column:reporting_scanners" faker:"oneof: |scanner1|, |scanner1||scanner2|"`
	Source            models.VulnerabilitySource `json:"source,omitempty" gorm:"column:source" faker:"oneof: CICD, RUNTIME"`
}

type VulnerabilityView struct {
	Vulnerability
	Resources      int    `json:"resources,omitempty" gorm:"column:resources"`
	Applications   int    `json:"applications,omitempty" gorm:"column:applications"`
	PackageID      string `json:"package_id,omitempty" gorm:"column:package_id"`
	PackageName    string `json:"package_name,omitempty" gorm:"column:package_name"`
	PackageVersion string `json:"package_version,omitempty" gorm:"column:package_version"`
	FixVersion     string `json:"fix_version,omitempty" gorm:"column:fix_version"`
}

type GetVulnerabilitiesParams struct {
	operations.GetVulnerabilitiesParams
	// List of application IDs that were affected by the last runtime scan.
	RuntimeScanApplicationIDs []string
}

type VulnerabilityTable interface {
	Create(vul *Vulnerability) error
	GetVulnerability(vulID, pkgID string) (*models.VulnerabilityEx, error)
	GetVulnerabilitiesAndTotal(params GetVulnerabilitiesParams) ([]VulnerabilityView, int64, error)
	CountVulnerabilitiesWithFix() ([]*models.VulnerabilitiesWithFix, error)
	CountPerSeverity(filters *CountFilters) ([]*models.VulnerabilityCount, error)
	Count(filters *CountFilters) (int64, error)
	DeleteByIDs(vulIDs []string) error
	GetDBVulnerability(id string) (*Vulnerability, error)
}

type VulnerabilityTableHandler struct {
	vulnerabilitiesTable *gorm.DB
	vulnerabilitiesView  *gorm.DB
	IDsView              IDsView
	viewRefreshHandler   *ViewRefreshHandler
}

func (Vulnerability) TableName() string {
	return vulnerabilityTableName
}

func CreateVulnerability(vul *types.PackageVulnerabilityScan, params *TransactionParams) Vulnerability {
	return Vulnerability{
		ID:                CreateVulnerabilityID(vul),
		Name:              vul.VulnerabilityName,
		ScannedAt:         params.Timestamp,
		Severity:          int(TypesVulnerabilitySeverityToInt[vul.Severity]),
		Description:       vul.Description,
		Links:             ArrayToDBArray(vul.Links),
		CVSS:              CreateCVSSString(vul.Cvss),
		CVSSBaseScore:     vul.Cvss.GetBaseScore(),
		CVSSSeverity:      int(ModelsVulnerabilitySeverityToInt[vul.Cvss.GetCVSSSeverity()]),
		ReportingScanners: ArrayToDBArray(vul.Scanners),
		Source:            params.VulnerabilitySource,
	}
}

func CreateCVSSString(cvss *types.CVSS) string {
	cvssB, err := json.Marshal(cvss)
	if err != nil {
		log.Errorf("Failed to marshal cvss: %v", err)
		return ""
	}
	return string(cvssB)
}

func CreateVulnerabilityID(vul *types.PackageVulnerabilityScan) string {
	return uuid.NewV5(uuid.Nil, vul.VulnerabilityName).String()
}

func (v *VulnerabilityTableHandler) Create(vul *Vulnerability) error {
	if err := v.vulnerabilitiesTable.Create(vul).Error; err != nil {
		return fmt.Errorf("failed to create vulnerability: %v", err)
	}

	v.viewRefreshHandler.TableChanged(vulnerabilityTableName)

	return nil
}

func (v *VulnerabilityTableHandler) DeleteByIDs(vulIDs []string) error {
	if len(vulIDs) == 0 {
		return nil
	}
	if err := v.vulnerabilitiesTable.Delete(&Vulnerability{}, vulIDs).Error; err != nil {
		return fmt.Errorf("failed to delete vulnerability: %v", err)
	}

	v.viewRefreshHandler.TableChanged(vulnerabilityTableName)

	return nil
}

func (v *VulnerabilityTableHandler) GetDBVulnerability(id string) (*Vulnerability, error) {
	var vul Vulnerability

	tx := v.vulnerabilitiesTable.
		Where(vulnerabilityTableName+"."+columnVulID+" = ?", id)

	if err := tx.First(&vul).Error; err != nil {
		return nil, fmt.Errorf("failed to get vulnerability by id %q: %v", id, err)
	}

	return &vul, nil
}

func (v *VulnerabilityTableHandler) setVulnerabilitiesFilters(params GetVulnerabilitiesParams) (*gorm.DB, error) {
	tx := v.vulnerabilitiesView

	// vulnerability name filters
	tx = FilterIs(tx, columnVulName, params.VulnerabilityNameIs)
	tx = FilterIsNot(tx, columnVulName, params.VulnerabilityNameIsNot)
	tx = FilterContains(tx, columnVulName, params.VulnerabilityNameContains)
	tx = FilterStartsWith(tx, columnVulName, params.VulnerabilityNameStart)
	tx = FilterEndsWith(tx, columnVulName, params.VulnerabilityNameEnd)

	// package name filters
	tx = FilterIs(tx, columnVulViewPackageName, params.PackageNameIs)
	tx = FilterIsNot(tx, columnVulViewPackageName, params.PackageNameIsNot)
	tx = FilterContains(tx, columnVulViewPackageName, params.PackageNameContains)
	tx = FilterStartsWith(tx, columnVulViewPackageName, params.PackageNameStart)
	tx = FilterEndsWith(tx, columnVulViewPackageName, params.PackageNameEnd)

	// package version filters
	tx = FilterIs(tx, columnVulViewPackageVersion, params.PackageVersionIs)
	tx = FilterIsNot(tx, columnVulViewPackageVersion, params.PackageVersionIsNot)
	tx = FilterContains(tx, columnVulViewPackageVersion, params.PackageVersionContains)
	tx = FilterStartsWith(tx, columnVulViewPackageVersion, params.PackageVersionStart)
	tx = FilterEndsWith(tx, columnVulViewPackageVersion, params.PackageVersionEnd)

	// severity filter
	tx = SeverityFilterIs(tx, columnVulSeverity, params.VulnerabilitySeverityIs)
	tx = SeverityFilterIsNot(tx, columnVulSeverity, params.VulnerabilitySeverityIsNot)
	tx = SeverityFilterGte(tx, columnVulSeverity, params.VulnerabilitySeverityGte)
	tx = SeverityFilterLte(tx, columnVulSeverity, params.VulnerabilitySeverityLte)

	// applicationResources filters
	tx = FilterGte(tx, columnApplicationViewResources, params.ApplicationResourcesGte)
	tx = FilterLte(tx, columnApplicationViewResources, params.ApplicationResourcesLte)
	tx = FilterIsNumber(tx, columnApplicationViewResources, params.ApplicationResourcesIs)
	tx = FilterIsNotNumber(tx, columnApplicationViewResources, params.ApplicationResourcesIsNot)

	// applications filter
	tx = FilterGte(tx, columnPkgViewApplications, params.ApplicationsGte)
	tx = FilterLte(tx, columnPkgViewApplications, params.ApplicationsLte)
	tx = FilterIsNumber(tx, columnPkgViewApplications, params.ApplicationsIs)
	tx = FilterIsNotNumber(tx, columnPkgViewApplications, params.ApplicationsIsNot)

	if params.HasFixVersionIs != nil {
		if *params.HasFixVersionIs {
			tx = FilterIsNotEmptyString(tx, columnVulViewFixVersion)
		} else {
			tx = FilterIsEmptyString(tx, columnVulViewFixVersion)
		}
	}

	// source filters
	tx = FilterIs(tx, columnVulSource, params.VulnerabilitySourceIs)

	tx = FilterArrayContains(tx, columnVulReportingScanners, params.ReportingScannersContainElements)
	tx = FilterArrayDoesntContain(tx, columnVulReportingScanners, params.ReportingScannersDoesntContainElements)

	// system filter
	var err error
	if tx, err = v.setSystemFilters(tx, params); err != nil {
		return nil, fmt.Errorf("failed to set system filters: %v", err)
	}

	return tx, nil
}

// setSystemFilters filters by vulID and packageID.
func (v *VulnerabilityTableHandler) setSystemFilters(tx *gorm.DB, params GetVulnerabilitiesParams) (*gorm.DB, error) {
	ids, err := v.getIDsByLookupID(params, VulnerabilityIDType)
	if err != nil {
		return nil, fmt.Errorf("failed to get vulnerability IDs by VulID: %v", err)
	}
	tx = FilterIs(tx, columnVulViewVulID, ids)

	ids, err = v.getIDsByLookupID(params, PackageIDType)
	if err != nil {
		return nil, fmt.Errorf("failed to get vulnerability IDs by PackageID: %v", err)
	}
	tx = FilterIs(tx, columnVulViewPkgID, ids)

	return tx, nil
}

func (v *VulnerabilityTableHandler) getIDsByLookupID(params GetVulnerabilitiesParams, lookupIDType idType) ([]string, error) {
	ids, err := v.IDsView.GetIDs(v.createGetIDsParams(params, lookupIDType), true)
	if err != nil {
		return nil, fmt.Errorf("failed to get IDs: %v", err)
	}

	return ids, nil
}

func (v *VulnerabilityTableHandler) createGetIDsParams(params GetVulnerabilitiesParams, lookupIDType idType) GetIDsParams {
	retParams := GetIDsParams{
		LookupIDType: lookupIDType,
	}

	// system filters - only one is allowed
	if params.CurrentRuntimeScan != nil && *params.CurrentRuntimeScan {
		retParams.FilterIDType = ApplicationIDType
		retParams.FilterIDs = params.RuntimeScanApplicationIDs
	} else if params.ApplicationID != nil {
		retParams.FilterIDType = ApplicationIDType
		retParams.FilterIDs = []string{*params.ApplicationID}
	} else if params.ApplicationResourceID != nil {
		retParams.FilterIDType = ResourceIDType
		retParams.FilterIDs = []string{*params.ApplicationResourceID}
	}

	return retParams
}

func VulnerabilityFromDB(view *VulnerabilityView) *models.Vulnerability {
	return &models.Vulnerability{
		ApplicationResources: uint32(view.Resources),
		Applications:         uint32(view.Applications),
		CvssBaseScore:        view.CVSSBaseScore,
		CvssSeverity:         CVSSSeverityIntToString[Severity(view.CVSSSeverity)],
		FixVersion:           view.FixVersion,
		ID:                   string(CreatePkgVulID(view.ID, view.PackageID)),
		PackageID:            view.PackageID,
		PackageName:          view.PackageName,
		PackageVersion:       view.PackageVersion,
		ReportingScanners:    DBArrayToArray(view.ReportingScanners),
		Severity:             SeverityIntToString[Severity(view.Severity)],
		Source:               view.Source,
		VulnerabilityID:      view.ID,
		VulnerabilityName:    view.Name,
	}
}

func (v *VulnerabilityTableHandler) GetVulnerability(vulID, pkgID string) (*models.VulnerabilityEx, error) {
	var view VulnerabilityView

	if err := v.vulnerabilitiesView.Where(vulnerabilityViewName+"."+columnVulID+" = ?", vulID).
		Where(vulnerabilityViewName+"."+columnVulViewPkgID+" = ?", pkgID).First(&view).Error; err != nil {
		return nil, fmt.Errorf("failed to get vulnerability by vulID %q and pkgID: %q: %v", vulID, pkgID, err)
	}

	cvss := types.CVSS{}
	if err := json.Unmarshal([]byte(view.CVSS), &cvss); err != nil {
		log.Errorf("Failed to unmarshal cvss: %v", view.CVSS)
	}

	return &models.VulnerabilityEx{
		Cvss:          (&cvss).ToCVSSBackendAPI(),
		Description:   view.Description,
		Links:         DBArrayToArray(view.Links),
		ScanDate:      strfmt.DateTime(view.ScannedAt),
		Vulnerability: VulnerabilityFromDB(&view),
	}, nil
}

const severityCountStmnt = "SUM(CASE WHEN severity = 0 THEN 1 ELSE 0 END) AS total_neg_count," +
	" SUM(CASE WHEN severity = 1 THEN 1 ELSE 0 END) AS total_low_count," +
	" SUM(CASE WHEN severity = 2 THEN 1 ELSE 0 END) AS total_medium_count," +
	" SUM(CASE WHEN severity = 3 THEN 1 ELSE 0 END) AS total_high_count," +
	" SUM(CASE WHEN severity = 4 THEN 1 ELSE 0 END) AS total_critical_count"

func (v *VulnerabilityTableHandler) CountVulnerabilitiesWithFix() ([]*models.VulnerabilitiesWithFix, error) {
	var severityCountersTotal SeverityCounters
	var severityCountersWithFix SeverityCounters

	tx := v.vulnerabilitiesView.Session(&gorm.Session{})
	if err := FilterIsNotEmptyString(tx, columnVulViewFixVersion).Select(severityCountStmnt).Scan(&severityCountersWithFix).Error; err != nil {
		return nil, err
	}

	tx = v.vulnerabilitiesView.Session(&gorm.Session{})
	if err := tx.Select(severityCountStmnt).Scan(&severityCountersTotal).Error; err != nil {
		return nil, err
	}

	vulCount := getVulnerabilityWithFixCount(severityCountersTotal, severityCountersWithFix)

	return vulCount, nil
}

func (v *VulnerabilityTableHandler) CountPerSeverity(filters *CountFilters) ([]*models.VulnerabilityCount, error) {
	var severityCounters SeverityCounters
	var err error

	tx := v.vulnerabilitiesView
	tx, err = v.setCountFilters(tx, filters)
	if err != nil {
		return nil, fmt.Errorf("failed to set count filters: %v", err)
	}

	if err := tx.Select(severityCountStmnt).Scan(&severityCounters).Error; err != nil {
		return nil, err
	}

	vulCount := getVulnerabilityCount(severityCounters)

	return vulCount, nil
}

func (v *VulnerabilityTableHandler) Count(filters *CountFilters) (int64, error) {
	var count int64
	var err error

	tx := v.vulnerabilitiesView

	tx, err = v.setCountFilters(tx, filters)
	if err != nil {
		return 0, fmt.Errorf("failed to set count filters: %v", err)
	}

	if err := tx.Count(&count).Error; err != nil {
		return 0, fmt.Errorf("failed to count total: %v", err)
	}
	return count, nil
}

func (v *VulnerabilityTableHandler) GetVulnerabilitiesAndTotal(params GetVulnerabilitiesParams) ([]VulnerabilityView, int64, error) {
	var count int64
	var vuls []VulnerabilityView

	tx, err := v.setVulnerabilitiesFilters(params)
	if err != nil {
		return nil, 0, fmt.Errorf("failed to set filters: %v", err)
	}

	// get total item count with the set filters
	if err := tx.Count(&count).Error; err != nil {
		return nil, 0, fmt.Errorf("failed to count total: %v", err)
	}

	sortOrder, err := createVulnerabilitiesSortOrder(params.SortKey, params.SortDir)
	if err != nil {
		return nil, 0, fmt.Errorf("failed to create sort order: %v", err)
	}

	// get specific page ordered items with the current filters
	if err := tx.Scopes(Paginate(params.Page, params.PageSize)).
		Order(sortOrder).
		Find(&vuls).Error; err != nil {
		return nil, 0, err
	}

	return vuls, count, nil
}

func createVulnerabilitiesSortOrder(sortKey string, sortDir *string) (string, error) {
	if models.VulnerabilitiesSortKey(sortKey) == models.VulnerabilitiesSortKeySeverity {
		return createSeverityColumnSortOrder(*sortDir)
	}

	sortKeyColumnName, err := getVulnerabilitiesSortKeyColumnName(sortKey)
	if err != nil {
		return "", fmt.Errorf("failed to get sort key column name: %v", err)
	}

	return fmt.Sprintf("%v %v", sortKeyColumnName, strings.ToLower(*sortDir)), nil
}

func createSeverityColumnSortOrder(sortDir string) (string, error) {
	return strings.Join(
		[]string{
			fmt.Sprintf("%v %v", columnVulSeverity, strings.ToLower(sortDir)),
			fmt.Sprintf("%v %v", columnVulCVSSBaseScore, strings.ToLower(sortDir)),
		}, ","), nil
}

func getVulnerabilitiesSortKeyColumnName(key string) (string, error) {
	switch models.VulnerabilitiesSortKey(key) {
	case models.VulnerabilitiesSortKeyFixVersion:
		return columnVulViewFixVersion, nil
	case models.VulnerabilitiesSortKeyVulnerabilityName:
		return columnVulName, nil
	case models.VulnerabilitiesSortKeyPackageName:
		return columnVulViewPackageName, nil
	case models.VulnerabilitiesSortKeyPackageVersion:
		return columnVulViewPackageVersion, nil
	case models.VulnerabilitiesSortKeySource:
		return columnVulSource, nil
	case models.VulnerabilitiesSortKeyApplications:
		return columnVulViewApplications, nil
	case models.VulnerabilitiesSortKeyApplicationResources:
		return columnVulViewResources, nil
	case models.VulnerabilitiesSortKeySeverity:
		return "", fmt.Errorf("unsupported key (%v)", key)
	}

	return "", fmt.Errorf("unknown sort key (%v)", key)
}

func (v *VulnerabilityTableHandler) setCountFilters(tx *gorm.DB, filters *CountFilters) (*gorm.DB, error) {
	if filters == nil {
		return tx, nil
	}

	// set application ids filter
	vulIds, err := v.IDsView.GetIDs(GetIDsParams{
		FilterIDs:    filters.ApplicationIDs,
		FilterIDType: ApplicationIDType,
		LookupIDType: VulnerabilityIDType,
	}, true)
	if err != nil {
		return tx, fmt.Errorf("failed to get vulnerability ids by app ids %v: %v", filters.ApplicationIDs, err)
	}
	tx = FilterIs(tx, columnVulViewVulID, vulIds)

	tx = SeverityFilterGte(tx, columnVulSeverity, filters.VulnerabilitySeverityGte)

	return tx, nil
}
